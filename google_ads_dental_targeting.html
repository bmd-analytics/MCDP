<!DOCTYPE html>
<html>
<head>
    <title>Google Ads Campaign Targeting Map</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        body { margin: 0; padding: 0; font-family: Arial, sans-serif; }
        #map { height: 100vh; width: 100%; }
        .legend { 
            background: white; 
            padding: 10px; 
            border-radius: 5px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            max-height: 300px;
            overflow-y: auto;
        }
        .legend h4 { margin: 0 0 10px 0; }
        .legend-item { margin: 3px 0; font-size: 12px; }
        .legend-color { 
            width: 15px; 
            height: 15px; 
            display: inline-block; 
            margin-right: 5px; 
            border: 1px solid #999;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
        }
        .debug {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 350px;
            max-height: 250px;
            overflow-y: auto;
            z-index: 1000;
        }
        .api-key-notice {
            background: #fff3cd;
            color: #856404;
            padding: 10px;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 11px;
        }
        .api-key-notice a {
            color: #0066cc;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">Loading campaign data...</div>
    <div id="debug" class="debug">
        <div class="api-key-notice">
            <strong>Setup Required:</strong> Get your free API key at 
            <a href="https://locationiq.com/" target="_blank">locationiq.com</a> 
            (5,000 requests/day free) and replace 'YOUR_LOCATIONIQ_API_KEY' in the code.
        </div>
        Debug info will appear here...
    </div>
    <div id="map"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script>
        // CONFIGURATION - Replace with your LocationIQ API key
        // Get free key at: https://locationiq.com/ (5,000 requests/day free tier)
        const LOCATIONIQ_API_KEY = 'pk.358098a68d38877064a347e670c88c90';
        
        // You can also use Geoapify (3,000/day free): https://www.geoapify.com/
        // const GEOAPIFY_API_KEY = 'YOUR_GEOAPIFY_API_KEY';

        // Global variable to store GeoJSON data for ZIP centroid fallback
        let zipGeoData = null;

        // Debug function
        function debugLog(message) {
            console.log(message);
            const debugDiv = document.getElementById('debug');
            const noticeDiv = debugDiv.querySelector('.api-key-notice');
            if (noticeDiv) {
                debugDiv.insertAdjacentHTML('beforeend', message + '<br>');
            } else {
                debugDiv.innerHTML += message + '<br>';
            }
            debugDiv.scrollTop = debugDiv.scrollHeight;
        }

        // Initialize map
        const map = L.map('map').setView([44.3, -84.5], 7);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);

        // Function to extract ZIP code from address
        function extractZipCode(address) {
            const zipMatch = address.match(/\b(\d{5})\b/);
            return zipMatch ? zipMatch[1] : null;
        }

        // Function to detect if location is a city name (not ZIP, not address with number)
        function isCityLocation(location) {
            if (!location) return false;
            
            // Check if it's a ZIP code format (starts with 5 digits)
            if (/^\d{5}/.test(location)) return false;
            
            // Check if it's a radius format (contains "mi|" or "mi radius")
            if (location.includes('mi|') || location.includes('mi radius')) return false;
            
            // Check if it has a street number (likely an address for radius targeting)
            if (/^\d+\s/.test(location)) return false;
            
            // If it matches pattern: "City Name, State" or "City Name, State, Country"
            // and doesn't have a ZIP code
            const parts = location.split(',').map(p => p.trim());
            if (parts.length >= 2 && !extractZipCode(location)) {
                // Check if first part looks like a city name (letters, spaces, maybe Township/City)
                const cityPart = parts[0];
                return /^[A-Za-z\s]+(?:Township|City)?$/i.test(cityPart);
            }
            
            return false;
        }

        // Function to geocode a city and find intersecting ZIP codes
        async function getZipsForCity(cityLocation, campaign) {
            debugLog(`Looking up ZIP codes for: ${cityLocation}`);
            
            try {
                // First geocode the city to get its coordinates
                const url = `https://us1.locationiq.com/v1/search?key=${LOCATIONIQ_API_KEY}&q=${encodeURIComponent(cityLocation)}&format=json&limit=1`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`Geocoding failed: ${response.status}`);
                }
                
                const results = await response.json();
                if (!results || results.length === 0) {
                    throw new Error('No results found');
                }
                
                const cityLat = parseFloat(results[0].lat);
                const cityLon = parseFloat(results[0].lon);
                const bbox = results[0].boundingbox; // [min_lat, max_lat, min_lon, max_lon]
                
                debugLog(`  Found: ${results[0].display_name}`);
                
                // Find all ZIP codes that intersect with this city's bounding box
                const matchingZips = [];
                
                if (zipGeoData && zipGeoData.features) {
                    zipGeoData.features.forEach(feature => {
                        const zipCode = feature.properties.ZCTA5CE10;
                        
                        // Check if ZIP's centroid is within expanded bounding box
                        let zipLat, zipLon;
                        
                        if (feature.geometry.type === 'Polygon') {
                            // Calculate centroid
                            let totalLat = 0, totalLon = 0, pointCount = 0;
                            feature.geometry.coordinates[0].forEach(coord => {
                                totalLon += coord[0];
                                totalLat += coord[1];
                                pointCount++;
                            });
                            zipLat = totalLat / pointCount;
                            zipLon = totalLon / pointCount;
                        } else if (feature.geometry.type === 'MultiPolygon') {
                            // Use first polygon for centroid
                            let totalLat = 0, totalLon = 0, pointCount = 0;
                            feature.geometry.coordinates[0][0].forEach(coord => {
                                totalLon += coord[0];
                                totalLat += coord[1];
                                pointCount++;
                            });
                            zipLat = totalLat / pointCount;
                            zipLon = totalLon / pointCount;
                        }
                        
                        // Check if ZIP centroid is within the city's bounding box (with small buffer)
                        const buffer = 0.02; // ~2km buffer
                        if (zipLat && zipLon &&
                            zipLat >= parseFloat(bbox[0]) - buffer &&
                            zipLat <= parseFloat(bbox[1]) + buffer &&
                            zipLon >= parseFloat(bbox[2]) - buffer &&
                            zipLon <= parseFloat(bbox[3]) + buffer) {
                            matchingZips.push(zipCode);
                        }
                    });
                }
                
                debugLog(`  Mapped to ${matchingZips.length} ZIP codes: ${matchingZips.join(', ')}`);
                return matchingZips;
                
            } catch (error) {
                debugLog(`  ✗ Failed to lookup ZIPs for ${cityLocation}: ${error.message}`);
                return [];
            }
        }

        // Function to get centroid of ZIP code from GeoJSON
        function getZipCentroid(zipCode) {
            if (!zipGeoData || !zipGeoData.features) {
                return null;
            }
            
            const feature = zipGeoData.features.find(f => 
                f.properties.ZCTA5CE10 === zipCode
            );
            
            if (!feature || !feature.geometry) {
                return null;
            }
            
            // Calculate centroid from polygon coordinates
            let totalLat = 0, totalLon = 0, pointCount = 0;
            
            if (feature.geometry.type === 'Polygon') {
                feature.geometry.coordinates[0].forEach(coord => {
                    totalLon += coord[0];
                    totalLat += coord[1];
                    pointCount++;
                });
            } else if (feature.geometry.type === 'MultiPolygon') {
                feature.geometry.coordinates.forEach(polygon => {
                    polygon[0].forEach(coord => {
                        totalLon += coord[0];
                        totalLat += coord[1];
                        pointCount++;
                    });
                });
            }
            
            if (pointCount > 0) {
                return {
                    lat: totalLat / pointCount,
                    lon: totalLon / pointCount,
                    display_name: `ZIP ${zipCode} (centroid)`
                };
            }
            
            return null;
        }

        // Function to load and process CSV data
        async function loadCampaignData() {
            try {
                debugLog('Attempting to fetch CSV...');
                const response = await fetch('google_ads_dental_targeting.csv');
                if (!response.ok) {
                    throw new Error(`Failed to load CSV: ${response.status} ${response.statusText}`);
                }
                
                const csvText = await response.text();
                debugLog(`CSV loaded: ${csvText.length} characters`);
                
                return new Promise((resolve, reject) => {
                    Papa.parse(csvText, {
                        header: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            if (results.errors.length > 0) {
                                console.warn('CSV parsing warnings:', results.errors);
                            }
                            debugLog(`CSV parsed: ${results.data.length} rows`);
                            resolve(results.data);
                        },
                        error: function(error) {
                            reject(error);
                        }
                    });
                });
            } catch (error) {
                console.error('Error loading campaign data:', error);
                throw error;
            }
        }

        // Geocode using LocationIQ (CORS-friendly, 5000 requests/day free)
        async function geocodeLocationIQ(address) {
            const url = `https://us1.locationiq.com/v1/search.php?key=${LOCATIONIQ_API_KEY}&q=${encodeURIComponent(address)}&format=json&countrycodes=us&limit=1`;
            
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const results = await response.json();
            
            if (results && results.length > 0) {
                return {
                    lat: parseFloat(results[0].lat),
                    lon: parseFloat(results[0].lon),
                    display_name: results[0].display_name
                };
            }
            
            throw new Error('No results found');
        }

        // Alternative: Geocode using Geoapify (CORS-friendly, 3000 requests/day free)
        async function geocodeGeoapify(address) {
            const GEOAPIFY_API_KEY = 'YOUR_GEOAPIFY_API_KEY'; // Replace if using Geoapify
            const url = `https://api.geoapify.com/v1/geocode/search?text=${encodeURIComponent(address)}&filter=countrycode:us&format=json&apiKey=${GEOAPIFY_API_KEY}`;
            
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            
            if (data.results && data.results.length > 0) {
                return {
                    lat: data.results[0].lat,
                    lon: data.results[0].lon,
                    display_name: data.results[0].formatted
                };
            }
            
            throw new Error('No results found');
        }

        // Main geocoding function with multi-stage fallback
        async function geocodeAddressWithFallback(address) {
            let lastError;
            
            // Stage 1: Try full address
            try {
                if (LOCATIONIQ_API_KEY && LOCATIONIQ_API_KEY !== 'YOUR_LOCATIONIQ_API_KEY') {
                    return await geocodeLocationIQ(address);
                } else {
                    throw new Error('Please configure LOCATIONIQ_API_KEY');
                }
            } catch (error) {
                lastError = error;
                debugLog(`└─ Stage 1 failed (${error.message}), trying fallbacks...`);
                
                // If we got a 408 timeout, skip API retries and go straight to ZIP centroid
                if (error.message.includes('408')) {
                    debugLog(`└─ Timeout detected, skipping API retries...`);
                    const zipCode = extractZipCode(address);
                    if (zipCode) {
                        const centroid = getZipCentroid(zipCode);
                        if (centroid) {
                            debugLog(`└─ ✓ Using ZIP centroid from GeoJSON: ${zipCode}`);
                            return {
                                ...centroid,
                                fallbackMethod: 'zip_centroid'
                            };
                        }
                    }
                    throw new Error(`Timeout and no ZIP centroid available: ${error.message}`);
                }
            }
            
            // Extract ZIP code for fallback attempts
            const zipCode = extractZipCode(address);
            
            // Stage 2a: Try ZIP code with API
            if (zipCode) {
                try {
                    await new Promise(resolve => setTimeout(resolve, 700)); // Add delay before retry
                    const zipResult = await geocodeLocationIQ(`${zipCode}, Michigan, United States`);
                    debugLog(`└─ ✓ Found using ZIP code API: "${zipCode}"`);
                    return {
                        ...zipResult,
                        fallbackMethod: 'zip_api'
                    };
                } catch (zipApiError) {
                    lastError = zipApiError;
                    debugLog(`└─ Stage 2a failed (ZIP API), continuing...`);
                    
                    // If timeout on retry, skip to centroid
                    if (zipApiError.message.includes('408')) {
                        debugLog(`└─ Timeout on ZIP API, using centroid...`);
                        const centroid = getZipCentroid(zipCode);
                        if (centroid) {
                            debugLog(`└─ ✓ Using ZIP centroid from GeoJSON: ${zipCode}`);
                            return {
                                ...centroid,
                                fallbackMethod: 'zip_centroid'
                            };
                        }
                    }
                }
            }
            
            // Stage 2b: Try city/state/ZIP from address parts
            const parts = address.split(',').map(p => p.trim());
            if (parts.length >= 2) {
                try {
                    await new Promise(resolve => setTimeout(resolve, 700)); // Add delay before retry
                    const cityStateZip = parts.slice(-2).join(', ');
                    const result = await geocodeLocationIQ(cityStateZip);
                    debugLog(`└─ ✓ Found using city/state: "${cityStateZip}"`);
                    return {
                        ...result,
                        fallbackMethod: 'city_state_zip'
                    };
                } catch (fallbackError) {
                    lastError = fallbackError;
                    debugLog(`└─ Stage 2b failed (city/state), continuing...`);
                }
            }
            
            // Stage 3: Final fallback - use ZIP centroid from GeoJSON
            if (zipCode) {
                const centroid = getZipCentroid(zipCode);
                if (centroid) {
                    debugLog(`└─ ✓ Using ZIP centroid from GeoJSON: ${zipCode}`);
                    return {
                        ...centroid,
                        fallbackMethod: 'zip_centroid'
                    };
                } else {
                    debugLog(`└─ ZIP centroid not found in GeoJSON for ${zipCode}`);
                }
            }
            
            throw new Error(`All geocoding methods failed: ${lastError?.message || 'Unknown error'}`);
        }

        // Initialize map with data
        async function initializeMap() {
            try {
                debugLog('Loading campaign data...');
                const campaignData = await loadCampaignData();

                // Parse the data
                const radiusTargets = [];
                const zipToCampaign = {};
                const cityTargets = [];

                campaignData.forEach(row => {
                    if (row.Location && row.Location.includes('|mi|')) {
                        // Radius targeting with pipe format: "10.0|mi|address"
                        const parts = row.Location.split('|mi|');
                        if (parts.length === 2) {
                            const radius = parseFloat(parts[0]);
                            const address = parts[1].trim();
                            radiusTargets.push({
                                address: address,
                                radius: radius,
                                campaign: row.Campaign
                            });
                        }
                    } else if (row.Location && row.Location.includes('radius')) {
                        // Legacy radius format: "address;10 mi radius"
                        const match = row.Location.match(/(.*);(\d+)\s*mi\s*radius/);
                        if (match) {
                            const address = match[1].trim();
                            const radius = parseInt(match[2]);
                            radiusTargets.push({
                                address: address,
                                radius: radius,
                                campaign: row.Campaign
                            });
                        }
                    } else if (row.Location && isCityLocation(row.Location)) {
                        // City-based location: "Fenton, Michigan, United States"
                        cityTargets.push({
                            location: row.Location,
                            campaign: row.Campaign
                        });
                    } else if (row.Location) {
                        // Regular ZIP code: "48423, Michigan, United States"
                        const zip = row.Location.split(',')[0];
                        if (/^\d{5}$/.test(zip)) {
                            zipToCampaign[zip] = row.Campaign;
                        }
                    }
                });

                debugLog(`Found ${radiusTargets.length} radius targets`);
                debugLog(`Found ${cityTargets.length} city targets`);
                debugLog(`Found ${Object.keys(zipToCampaign).length} ZIP codes`);

                // Check API key configuration
                if (LOCATIONIQ_API_KEY === 'YOUR_LOCATIONIQ_API_KEY') {
                    debugLog('⚠️ WARNING: API key not configured!');
                    debugLog('Get free key at locationiq.com');
                } else {
                    debugLog('✓ API key configured');
                }

                // Generate colors for campaigns
                const campaigns = [...new Set(campaignData.map(row => row.Campaign).filter(Boolean))];
                const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'];
                const campaignColors = {};
                campaigns.forEach((campaign, i) => {
                    campaignColors[campaign] = colors[i % colors.length];
                });

                // Style function for ZIP codes
                function getStyle(feature) {
                    const zip = feature.properties.ZCTA5CE10;
                    const campaign = zipToCampaign[zip];
                    return {
                        fillColor: campaign ? campaignColors[campaign] : '#cccccc',
                        weight: 1,
                        opacity: 1,
                        color: 'white',
                        fillOpacity: 0.7
                    };
                }

                // Add ZIP polygons to map
                function onEachFeature(feature, layer) {
                    const zip = feature.properties.ZCTA5CE10;
                    const campaign = zipToCampaign[zip];
                    if (campaign) {
                        layer.bindPopup(`<b>ZIP: ${zip}</b><br>${campaign}`);
                    }
                }

                // Load GeoJSON file
                try {
                    const geoResponse = await fetch('mi_michigan_zip_codes_geo.min.json');
                    if (geoResponse.ok) {
                        const data = await geoResponse.json();
                        zipGeoData = data; // Store for centroid fallback
                        console.log('GeoJSON loaded, features:', data.features?.length);
                        debugLog(`GeoJSON loaded: ${data.features?.length} features`);
                        
                        // Add ZIP polygons
                        L.geoJSON(data, {
                            style: getStyle,
                            onEachFeature: onEachFeature
                        }).addTo(map);
                    } else {
                        debugLog('⚠️ GeoJSON file not found');
                    }
                } catch (geoError) {
                    console.warn('Failed to load GeoJSON:', geoError);
                    debugLog(`⚠️ GeoJSON error: ${geoError.message}`);
                }
                
                // Process city-based targets to find their ZIP codes
                if (cityTargets.length > 0 && zipGeoData) {
                    debugLog(`Processing ${cityTargets.length} city-based targets...`);
                    
                    for (const target of cityTargets) {
                        const zips = await getZipsForCity(target.location, target.campaign);
                        
                        // Add each ZIP to the campaign mapping
                        zips.forEach(zip => {
                            // Don't overwrite existing ZIP assignments
                            if (!zipToCampaign[zip]) {
                                zipToCampaign[zip] = target.campaign;
                            }
                        });
                        
                        // Rate limiting
                        await new Promise(resolve => setTimeout(resolve, 600));
                    }
                    
                    // Redraw the map with updated ZIP assignments
                    debugLog(`City processing complete. Redrawing map...`);
                    
                    // Remove old GeoJSON layer and add new one with updated colors
                    map.eachLayer(layer => {
                        if (layer.feature) {
                            map.removeLayer(layer);
                        }
                    });
                    
                    // Re-add ZIP polygons with updated campaign assignments
                    try {
                        const geoResponse = await fetch('mi_michigan_zip_codes_geo.min.json');
                        if (geoResponse.ok) {
                            const data = await geoResponse.json();
                            L.geoJSON(data, {
                                style: getStyle,
                                onEachFeature: onEachFeature
                            }).addTo(map);
                        }
                    } catch (error) {
                        debugLog(`⚠️ Error redrawing map: ${error.message}`);
                    }
                }
                
                // Add radius circles
                let successCount = 0;
                let failCount = 0;
                let fallbackStats = {
                    direct: 0,
                    zip_api: 0,
                    city_state_zip: 0,
                    zip_centroid: 0
                };
                
                if (radiusTargets.length > 0) {
                    debugLog(`Starting geocoding with multi-stage fallbacks for ${radiusTargets.length} addresses...`);
                    
                    for (let i = 0; i < radiusTargets.length; i++) {
                        const target = radiusTargets[i];
                        debugLog(`Geocoding ${i + 1}/${radiusTargets.length}: ${target.address}`);
                        
                        try {
                            const result = await geocodeAddressWithFallback(target.address);
                            
                            // Track fallback method
                            if (result.fallbackMethod) {
                                fallbackStats[result.fallbackMethod]++;
                            } else {
                                fallbackStats.direct++;
                            }
                            
                            // Add circle to map
                            const circle = L.circle([result.lat, result.lon], {
                                color: campaignColors[target.campaign],
                                fillColor: campaignColors[target.campaign],
                                fillOpacity: 0.3,
                                radius: target.radius * 1609.34 // Convert miles to meters
                            }).addTo(map);
                            
                            // Add popup with fallback method indicator
                            let methodNote = '';
                            if (result.fallbackMethod === 'city_state_zip') {
                                methodNote = '<br><small style="color: orange;">⚠️ Using city/state fallback</small>';
                            } else if (result.fallbackMethod === 'zip_api') {
                                methodNote = '<br><small style="color: orange;">⚠️ Using ZIP code API</small>';
                            } else if (result.fallbackMethod === 'zip_centroid') {
                                methodNote = '<br><small style="color: orange;">⚠️ Using ZIP centroid</small>';
                            }
                            
                            circle.bindPopup(`
                                <b>${target.campaign}</b><br>
                                ${target.radius} mile radius<br>
                                ${target.address}<br>
                                <small>${result.display_name}</small>
                                ${methodNote}
                            `);
                            
                            debugLog(`✓ Success: ${target.address}`);
                            successCount++;
                            
                            // Rate limiting: LocationIQ free tier is 2 requests/second
                            if (i < radiusTargets.length - 1) {
                                await new Promise(resolve => setTimeout(resolve, 600)); // 600ms delay = ~1.5 req/sec
                            }
                            
                        } catch (error) {
                            debugLog(`✗ Failed: ${target.address} (${error.message})`);
                            failCount++;
                        }
                    }

                    const fallbackSummary = `(${fallbackStats.direct} direct, ${fallbackStats.zip_api} ZIP API, ${fallbackStats.city_state_zip} city/state, ${fallbackStats.zip_centroid} centroid)`;
                    debugLog(`Geocoding complete! ✓${successCount} success ${fallbackSummary}, ✗${failCount} failed`);
                }

                // Create legend
                const legend = L.control({position: 'topright'});
                legend.onAdd = function() {
                    const div = L.DomUtil.create('div', 'legend');
                    div.innerHTML = '<h4>Campaign Targeting</h4>';
                    campaigns.forEach(campaign => {
                        div.innerHTML += `<div class="legend-item">
                            <span class="legend-color" style="background: ${campaignColors[campaign]}"></span>
                            ${campaign.replace(/^[A-Z]+-/, '')}
                        </div>`;
                    });
                    return div;
                };
                legend.addTo(map);

                // Hide loading indicator
                document.getElementById('loading').style.display = 'none';
                
                // Auto-hide debug info after 15 seconds if successful
                if (successCount > 0 || Object.keys(zipToCampaign).length > 0) {
                    setTimeout(() => {
                        document.getElementById('debug').style.display = 'none';
                    }, 15000);
                }

            } catch (error) {
                console.error('Error initializing map:', error);
                document.getElementById('loading').innerHTML = `Error loading data: ${error.message}`;
                debugLog(`ERROR: ${error.message}`);
            }
        }

        // Initialize the map when page loads
        initializeMap();
    </script>
</body>
</html>
