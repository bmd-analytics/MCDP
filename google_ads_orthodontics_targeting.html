<!DOCTYPE html>
<html>
<head>
    <title>Google Ads Campaign Targeting Map - Orthodontics</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        body { margin: 0; padding: 0; font-family: Arial, sans-serif; }
        #map { height: 100vh; width: 100%; }
        .legend { 
            background: white; 
            padding: 10px; 
            border-radius: 5px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            max-height: 300px;
            overflow-y: auto;
        }
        .legend h4 { margin: 0 0 10px 0; }
        .legend-item { margin: 3px 0; font-size: 12px; }
        .legend-color { 
            width: 15px; 
            height: 15px; 
            display: inline-block; 
            margin-right: 5px; 
            border: 1px solid #999;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
        }
        .debug {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 350px;
            max-height: 250px;
            overflow-y: auto;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">Loading campaign data...</div>
    <div id="debug" class="debug">Debug info will appear here...</div>
    <div id="map"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script>
        // Debug function
        function debugLog(message) {
            console.log(message);
            const debugDiv = document.getElementById('debug');
            debugDiv.innerHTML += message + '<br>';
            debugDiv.scrollTop = debugDiv.scrollHeight;
        }

        // Initialize map
        const map = L.map('map').setView([44.3, -84.5], 7);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);

        // Extract ZIP code from address
        function extractZipCode(address) {
            const zipMatch = address.match(/\b(\d{5})\b/);
            return zipMatch ? zipMatch[1] : null;
        }

        // Get centroid coordinates for a ZIP code from GeoJSON
        function getZipCentroid(zipCode, geoData) {
            if (!geoData || !geoData.features) return null;
            
            const feature = geoData.features.find(f => 
                f.properties.ZCTA5CE10 === zipCode
            );
            
            if (!feature || !feature.geometry) return null;
            
            // Calculate centroid from polygon coordinates
            let totalLat = 0, totalLon = 0, pointCount = 0;
            
            if (feature.geometry.type === 'Polygon') {
                feature.geometry.coordinates[0].forEach(coord => {
                    totalLon += coord[0];
                    totalLat += coord[1];
                    pointCount++;
                });
            } else if (feature.geometry.type === 'MultiPolygon') {
                feature.geometry.coordinates.forEach(polygon => {
                    polygon[0].forEach(coord => {
                        totalLon += coord[0];
                        totalLat += coord[1];
                        pointCount++;
                    });
                });
            }
            
            if (pointCount > 0) {
                return {
                    lat: totalLat / pointCount,
                    lon: totalLon / pointCount
                };
            }
            
            return null;
        }

        // Load and process CSV data
        async function loadCampaignData() {
            try {
                debugLog('Loading CSV file...');
                const response = await fetch('google_ads_orthodontics_targeting.csv');
                if (!response.ok) {
                    throw new Error(`Failed to load CSV: ${response.status}`);
                }
                
                const csvText = await response.text();
                debugLog(`CSV loaded: ${csvText.length} characters`);
                
                return new Promise((resolve, reject) => {
                    Papa.parse(csvText, {
                        header: true,
                        skipEmptyLines: true,
                        complete: (results) => {
                            debugLog(`CSV parsed: ${results.data.length} rows`);
                            resolve(results.data);
                        },
                        error: reject
                    });
                });
            } catch (error) {
                console.error('Error loading campaign data:', error);
                throw error;
            }
        }

        // Initialize map
        async function initializeMap() {
            try {
                const campaignData = await loadCampaignData();

                // Parse data
                const radiusTargets = [];
                const zipToCampaign = {};

                campaignData.forEach(row => {
                    if (row.Location && row.Location.includes('|mi|')) {
                        // Radius targeting: "10.0|mi|address"
                        const parts = row.Location.split('|mi|');
                        if (parts.length === 2) {
                            const radius = parseFloat(parts[0]);
                            const address = parts[1].trim();
                            const zipCode = extractZipCode(address);
                            
                            if (zipCode) {
                                radiusTargets.push({
                                    address: address,
                                    radius: radius,
                                    campaign: row.Campaign,
                                    zipCode: zipCode
                                });
                            }
                        }
                    } else if (row.Location) {
                        // Regular ZIP code targeting
                        const zip = row.Location.split(',')[0];
                        zipToCampaign[zip] = row.Campaign;
                    }
                });

                debugLog(`Found ${radiusTargets.length} radius targets`);
                debugLog(`Found ${Object.keys(zipToCampaign).length} ZIP codes`);

                // Generate colors for campaigns
                const campaigns = [...new Set(campaignData.map(row => row.Campaign).filter(Boolean))];
                const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'];
                const campaignColors = {};
                campaigns.forEach((campaign, i) => {
                    campaignColors[campaign] = colors[i % colors.length];
                });

                // Load GeoJSON
                const geoResponse = await fetch('mi_michigan_zip_codes_geo.min.json');
                if (!geoResponse.ok) {
                    throw new Error('Failed to load GeoJSON');
                }
                
                const geoData = await geoResponse.json();
                debugLog(`GeoJSON loaded: ${geoData.features.length} features`);

                // Style function for ZIP polygons
                function getStyle(feature) {
                    const zip = feature.properties.ZCTA5CE10;
                    const campaign = zipToCampaign[zip];
                    return {
                        fillColor: campaign ? campaignColors[campaign] : '#cccccc',
                        weight: 1,
                        opacity: 1,
                        color: 'white',
                        fillOpacity: 0.7
                    };
                }

                // Add ZIP polygons
                function onEachFeature(feature, layer) {
                    const zip = feature.properties.ZCTA5CE10;
                    const campaign = zipToCampaign[zip];
                    if (campaign) {
                        layer.bindPopup(`<b>ZIP: ${zip}</b><br>${campaign}`);
                    }
                }

                L.geoJSON(geoData, {
                    style: getStyle,
                    onEachFeature: onEachFeature
                }).addTo(map);

                // Add radius circles using ZIP centroids
                let successCount = 0;
                let failCount = 0;

                radiusTargets.forEach(target => {
                    const centroid = getZipCentroid(target.zipCode, geoData);
                    
                    if (centroid) {
                        const circle = L.circle([centroid.lat, centroid.lon], {
                            color: campaignColors[target.campaign],
                            fillColor: campaignColors[target.campaign],
                            fillOpacity: 0.3,
                            radius: target.radius * 1609.34 // Convert miles to meters
                        }).addTo(map);
                        
                        circle.bindPopup(`
                            <b>${target.campaign}</b><br>
                            ${target.radius} mile radius<br>
                            ${target.address}<br>
                            <small>Centered on ZIP ${target.zipCode}</small>
                        `);
                        
                        debugLog(`✓ ${target.address} (ZIP ${target.zipCode})`);
                        successCount++;
                    } else {
                        debugLog(`✗ ZIP ${target.zipCode} not found in GeoJSON`);
                        failCount++;
                    }
                });

                debugLog(`Complete! ✓${successCount} success, ✗${failCount} failed`);

                // Create legend
                const legend = L.control({position: 'topright'});
                legend.onAdd = function() {
                    const div = L.DomUtil.create('div', 'legend');
                    div.innerHTML = '<h4>Campaign Targeting</h4>';
                    campaigns.forEach(campaign => {
                        div.innerHTML += `<div class="legend-item">
                            <span class="legend-color" style="background: ${campaignColors[campaign]}"></span>
                            ${campaign.replace(/^[A-Z]+-/, '')}
                        </div>`;
                    });
                    return div;
                };
                legend.addTo(map);

                // Hide loading
                document.getElementById('loading').style.display = 'none';
                
                // Auto-hide debug after 10 seconds
                setTimeout(() => {
                    document.getElementById('debug').style.display = 'none';
                }, 10000);

            } catch (error) {
                console.error('Error:', error);
                document.getElementById('loading').innerHTML = `Error: ${error.message}`;
                debugLog(`ERROR: ${error.message}`);
            }
        }

        // Start
        initializeMap();
    </script>
</body>
</html>
